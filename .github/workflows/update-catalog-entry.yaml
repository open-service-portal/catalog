# Reusable workflow for updating catalog entries
# This workflow can be called from other repositories in the organization
# to update their package references in the catalog
name: Update Catalog Entry

on:
  workflow_call:
    inputs:
      package-name:
        description: 'Name of the package (e.g. template-dns-record)'
        required: true
        type: string
      version:
        description: 'Version of the package to update to (e.g. v1.1.0)'
        required: true
        type: string
      registry:
        description: 'Container registry hosting the package (e.g. ghcr.io)'
        required: true
        type: string
      organisation:
        description: 'Organization or user owning the package (e.g. open-service-portal)'
        required: true
        type: string

    outputs:
      pr-url:
        description: 'URL of the created pull request'
        value: ${{ jobs.create-pr.outputs.pr-url }}

jobs:
  # Job 1: Check if package exists and determine action
  prepare:
    name: Check Package Status
    runs-on: ubuntu-latest
    
    outputs:
      package-exists: ${{ steps.check-package.outputs.exists }}
      action: ${{ steps.check-package.outputs.action }}
      app-slug: ${{ steps.app-token.outputs.app-slug }}
      user-id: ${{ steps.get-user-id.outputs.user-id }}
    
    steps:
      # Generate GitHub App token for catalog updates
      - name: Generate GitHub App Token
        id: app-token
        uses: actions/create-github-app-token@v2
        with:
          app-id: ${{ vars.APP_CATALOG_CLIENT_ID }}
          private-key: ${{ secrets.APP_CATALOG_PRIVATE_KEY }}
          owner: open-service-portal
          repositories: catalog

      - name: Get GitHub App User ID
        id: get-user-id
        run: echo "user-id=$(gh api "/users/${{ steps.app-token.outputs.app-slug }}[bot]" --jq .id)" >> "$GITHUB_OUTPUT"
        env:
          GH_TOKEN: ${{ steps.app-token.outputs.token }}

      - name: Checkout Catalog Repository
        uses: actions/checkout@v5
        with:
          repository: open-service-portal/catalog
          token: ${{ steps.app-token.outputs.token }}
          fetch-depth: 0

      - name: Check if package exists in catalog
        id: check-package
        env:
          CATALOG_FILE: templates/${{ inputs.package-name }}.yaml
        run: |
          echo "📁 Current directory: $(pwd)"
          echo "📋 Looking for: ${CATALOG_FILE}"
          ls -la templates/ || echo "Templates directory not found"
          
          if [ -f "${CATALOG_FILE}" ]; then
            echo "✅ Package already exists in catalog: ${CATALOG_FILE}"
            echo "exists=true" >> "$GITHUB_OUTPUT"
            echo "action=update" >> "$GITHUB_OUTPUT"
          else
            echo "📦 Package not found in catalog - will add as new"
            echo "exists=false" >> "$GITHUB_OUTPUT"
            echo "action=add" >> "$GITHUB_OUTPUT"
          fi

  # Job 2: Generate catalog entry and commit changes
  update-catalog:
    name: Update Catalog Files
    runs-on: ubuntu-latest
    needs: prepare
    
    env:
      VERSION: ${{ inputs.version }}
      PACKAGE_NAME: ${{ inputs.package-name }}
      REGISTRY: ${{ inputs.registry }}
      ORGANISATION: ${{ inputs.organisation }}
      PKG_PATH: ${{ inputs.registry }}/${{ inputs.organisation }}/${{ inputs.package-name }}
    
    outputs:
      branch: ${{ steps.commit.outputs.branch }}
      skip: ${{ steps.commit.outputs.skip }}
    
    steps:
      # Generate NEW token for this job
      - name: Generate GitHub App Token
        id: app-token
        uses: actions/create-github-app-token@v2
        with:
          app-id: ${{ vars.APP_CATALOG_CLIENT_ID }}
          private-key: ${{ secrets.APP_CATALOG_PRIVATE_KEY }}
          owner: open-service-portal
          repositories: catalog
      
      - name: Checkout Catalog Repository
        uses: actions/checkout@v5
        with:
          repository: open-service-portal/catalog
          token: ${{ steps.app-token.outputs.token }}
          fetch-depth: 0

      - name: Configure Git
        run: |
          git config --global user.name '${{ needs.prepare.outputs.app-slug }}[bot]'
          git config --global user.email '${{ needs.prepare.outputs.user-id }}+${{ needs.prepare.outputs.app-slug }}[bot]@users.noreply.github.com'

      - name: Install Kustomize
        if: needs.prepare.outputs.action == 'add'
        run: |
          curl -s "https://raw.githubusercontent.com/kubernetes-sigs/kustomize/master/hack/install_kustomize.sh" | bash
          sudo mv kustomize /usr/local/bin/
          kustomize version

      - name: Generate catalog entry
        id: catalog-entry
        env:
          CATALOG_FILE: templates/${{ inputs.package-name }}.yaml
        run: |
          
          # Create catalog entry content
          cat > "${CATALOG_FILE}" <<EOF
          ---
          # Configuration Package: ${{ inputs.package-name }}
          # Registry: ${{ inputs.registry }}/${{ inputs.organisation }}
          apiVersion: pkg.crossplane.io/v1
          kind: Configuration
          metadata:
            name: ${{ inputs.package-name }}
            namespace: crossplane-system
          spec:
            package: ${PKG_PATH}:${VERSION}

            # Package pull policy
            # IfNotPresent: Only download if not in cache (recommended for production)
            # Always: Check for updates on reconciliation (useful for development)
            packagePullPolicy: IfNotPresent

            # Revision activation policy
            # Automatic: New revisions become active immediately (good for single-tenant)
            # Manual: Requires manual activation (safer for multi-tenant production)
            revisionActivationPolicy: Automatic

            # Number of inactive revisions to keep
            # Useful for rollback scenarios
            revisionHistoryLimit: 3

            # Skip dependency resolution
            # Set to true if providers are pre-installed in the cluster
            skipDependencyResolution: true
          EOF
          
          echo "📝 Catalog entry written to ${CATALOG_FILE}"

      - name: Update kustomization.yaml for new package
        if: needs.prepare.outputs.action == 'add'
        run: |
          # Add the new template to kustomization.yaml using kustomize
          TEMPLATE_PATH="templates/${{ inputs.package-name }}.yaml"
          
          echo "📝 Adding ${TEMPLATE_PATH} to kustomization.yaml"
          kustomize edit add resource ${TEMPLATE_PATH}

      - name: Create Branch and Stage Changes
        id: prepare-commit
        run: |
          # Create a unique branch name using action type
          BRANCH_NAME="${{ needs.prepare.outputs.action }}-${{ inputs.package-name }}-${{ inputs.version }}"
          
          # Check if branch already exists
          if git ls-remote --heads origin ${BRANCH_NAME} | grep -q ${BRANCH_NAME}; then
            echo "Branch ${BRANCH_NAME} already exists, adding timestamp"
            BRANCH_NAME="${BRANCH_NAME}-$(date +%s)"
          fi
          
          git checkout -b ${BRANCH_NAME}
          git add templates/${{ inputs.package-name }}.yaml
          
          # Also add kustomization.yaml if it was modified (for new packages)
          if [ "${{ needs.prepare.outputs.action }}" = "add" ]; then
            git add kustomization.yaml
          fi
          
          # Check if there are actual changes
          if git diff --cached --quiet; then
            echo "⚠️ No changes detected in catalog entry"
            echo "skip=true" >> "$GITHUB_OUTPUT"
            exit 0
          fi
          
          echo "branch=${BRANCH_NAME}" >> "$GITHUB_OUTPUT"
          echo "skip=false" >> "$GITHUB_OUTPUT"

      - name: Commit New Package Addition
        if: needs.prepare.outputs.action == 'add' && steps.prepare-commit.outputs.skip != 'true'
        run: |
          git commit -m "feat: add new package ${{ inputs.package-name }} ${{ inputs.version }}

          Package: ${PKG_PATH}:${{ inputs.version }}
          Registry: ${{ inputs.registry }}
          
          This adds a new package to the catalog."

      - name: Commit Package Update
        if: needs.prepare.outputs.action == 'update' && steps.prepare-commit.outputs.skip != 'true'
        run: |
          git commit -m "chore: update ${{ inputs.package-name }} to ${{ inputs.version }}

          Package: ${PKG_PATH}:${{ inputs.version }}
          Registry: ${{ inputs.registry }}
          
          This update was triggered by a new release in the source repository."

      - name: Push Changes
        id: commit
        if: steps.prepare-commit.outputs.skip != 'true'
        run: |
          git push origin ${{ steps.prepare-commit.outputs.branch }}
          
          # Pass outputs forward
          echo "branch=${{ steps.prepare-commit.outputs.branch }}" >> "$GITHUB_OUTPUT"
          echo "skip=${{ steps.prepare-commit.outputs.skip }}" >> "$GITHUB_OUTPUT"

  # Job 3: Create pull request
  create-pr:
    name: Create Pull Request
    runs-on: ubuntu-latest
    needs: [prepare, update-catalog]
    if: needs.update-catalog.outputs.skip != 'true'
    
    env:
      VERSION: ${{ inputs.version }}
      PACKAGE_NAME: ${{ inputs.package-name }}
      REGISTRY: ${{ inputs.registry }}
      ORGANISATION: ${{ inputs.organisation }}
    
    outputs:
      pr-url: ${{ steps.create-pr.outputs.pr-url }}
      pr-number: ${{ steps.create-pr.outputs.pr-number }}
    
    steps:
      # Generate NEW token for this job
      - name: Generate GitHub App Token
        id: app-token
        uses: actions/create-github-app-token@v2
        with:
          app-id: ${{ vars.APP_CATALOG_CLIENT_ID }}
          private-key: ${{ secrets.APP_CATALOG_PRIVATE_KEY }}
          owner: open-service-portal
          repositories: catalog
      
      - name: Checkout Catalog Repository
        uses: actions/checkout@v5
        with:
          repository: open-service-portal/catalog
          token: ${{ steps.app-token.outputs.token }}
          ref: ${{ needs.update-catalog.outputs.branch }}

      - name: Create Pull Request
        id: create-pr
        run: |
          # Determine PR title prefix based on action
          if [ "${{ needs.prepare.outputs.action }}" = "add" ]; then
            PR_PREFIX="feat: add new package"
          else
            PR_PREFIX="chore: update"
          fi
          
          # Create PR using action-specific template
          PR_TITLE="${PR_PREFIX} ${PACKAGE_NAME} ${VERSION}"
          
          # Add source repository information to the environment for the template
          # Since this is a reusable workflow, we link to the source repository
          export SOURCE_REPO="${{ inputs.organisation }}/${{ inputs.package-name }}"
          export SOURCE_REPO_URL="${{ github.server_url }}/${{ inputs.organisation }}/${{ inputs.package-name }}"
          
          PR_BODY=$(envsubst < .github/PULL_REQUEST_TEMPLATE/catalog-${{ needs.prepare.outputs.action }}.md)
          
          PR_URL=$(gh pr create \
            --title "${PR_TITLE}" \
            --body "$PR_BODY" \
            --base main \
            --head ${{ needs.update-catalog.outputs.branch }})
          
          echo "pr-url=${PR_URL}" >> "$GITHUB_OUTPUT"
          
          # Extract PR number from URL
          PR_NUMBER=$(echo "${PR_URL}" | grep -oE '[0-9]+$')
          echo "pr-number=${PR_NUMBER}" >> "$GITHUB_OUTPUT"
          
          echo "✅ Created PR: ${PR_URL}"
        env:
          GH_TOKEN: ${{ steps.app-token.outputs.token }}
